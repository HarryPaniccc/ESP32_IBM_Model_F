/*
Author: Harry Papanicolaou
Date: 21/02/2025

This code reads in the data line of an IBM Model F keyboard on the falling edge of the clock generated by the keyboard, and is meant to 
translate the bits received to the keys they represent. This is not meant to drive keyboard input.

*/

//GPIO pins used for the keyboard clock and data pins
int keyboard_clk = 25;
int keyboard_data = 26;

uint16_t output_character_code = 0; /* The data is sent supposedly in 8 bits plus 2 start bits on the front.
                                      So on interrupt we should read in data and feed the last integer of data out into the serial port. */

//tells us how far through the keystroke code we are so we can reset our count and output something.
int data_bit_number = 0;

uint8_t key_codes[8] = {1111000, 11111000, 100, 10000100, 1000100};


char keys[8] = {'a', 's', 'd', 'f', 'g'};



void IRAM_ATTR clock_falling_edge(){
  // output_character_code = (output_character_code >> 1) + (digitalRead(keyboard_data) << 8); //FREAKY mode - MSB is first telling if it is being pushed or released

  output_character_code = (output_character_code << 1) + digitalRead(keyboard_data); /* NORMAL mode - MSB is last telling if it is being pushed or released
                                                                                                      Leftmost bit is always 1 for some reason (might be the start(1) bit)*/

  data_bit_number++; //increment the bit by 1. If it reaches 10, we need to reset it.
}



void IRAM_ATTR check_code(uint8_t binary_keycode){
  //checks the keycode and outputs the key to the serial line
  int i = 0;

  while (true){
    if (binary_keycode == key_codes[i]){
      Serial.println(keys[i]);
      break;
    }
    i++;
  }
}



void setup() {
  Serial.begin(115200); //TODO: Maybe the baud rate needs to be upped? I think scaling it makes sense, but lets be sure about that first.
  
  // Set the pins to inputs/interrupts:

  pinMode(keyboard_clk, INPUT);
  attachInterrupt(keyboard_clk, clock_falling_edge, FALLING);

  pinMode(keyboard_data, INPUT);
}


void loop() {
  if (data_bit_number >= 10){
    check_code(output_character_code);
    // Serial.println(output_character_code, BIN); //Type 3 - if output_character_code is uint8_t then it just cuts off the start bits because of how this shit works. CANT USE FREAKY MODE.
    data_bit_number = 0;
    output_character_code = 0;
  }

}
